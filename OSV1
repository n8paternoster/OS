import "io"
import "basic"
 
// Displays user input on screen.
let echo(input) be 
{ 
  // TODO: Real echo gets rid of quotation marks.
  out("%s \n", input);
}

let time() be 
{
  let v = vec(7);
  let t = seconds();

  datetime(t, v);
  out("month: %d \n", v ! 1);
  out("day: %d \n", v ! 2);
  out("year: %d \n", v ! 0);
  // freevec(v);
}

// Exits the prompt.
let exit() be {
  finish;
}

// Compares strings. Returns 1 if equal, 0 if not.
let strcmp(a, b) be { 

  let i = 0; 

   while true do { 
     test byte i of a <> byte i of b then    
       resultis 0

     // If at the end of string, then the strings are equal.     
     else test byte i of a = 0  /\ byte i of b = 0 then  
       resultis 1

     else
       i +:= 1;
   }

   resultis 0;
}

let getline() be
{ let ch = 0;
  let str = vec(7);
  let i = 0;

  while true do {

    ch := inch();
    // out ("%d: %08x \n", i, str ! 0 ! 1);
    test ch = '\n' then
    {
      byte i of str ! 0 := 0;
      // out("iget cmd: %s \n", str ! 0);

      resultis str;
    }
  
    else
    {
      byte i of str ! 0 := ch;
      i +:= 1
    }
  }
  
  resultis str;
}

let parse(line, cmd, arg) be
{ let ch = "";
  let j = 0;
  let i = 0;

  out("line = %s \n", line);

  while true do {

    ch := byte i of line;
//    out("CMD : %d = %s\n", i, ch);

    test ch = ' ' then
    {
      byte i of cmd ! 0 := 0;
      break
    }

    else test ch = '\n' then
    {
      byte i of cmd ! 0 := 0;
      arg := "";
      // input_arr ! 0 := cmd;
      // input_arr ! 1 := arg;
      // resultis input_arr
      resultis 0;
    }

    else
    {
      byte i of cmd ! 0 := ch;
      i +:= 1
    }
  }

  while true do {

    ch := byte i of line;

    test ch = ' ' then
    {
      byte j of arg ! 0 := 0;
      break
    }

    else test ch = '\n' then
    {
      byte j of arg! 0 := 0;
      // input_arr ! 0 := cmd;
      // input_arr ! 1 := arg;
      // resultis input_arr
      resultis 0;
    }

    else
    {
      byte j of arg ! 0:= ch;
//      out("ARG ! %d = %s\n", i, ch);
      i +:= 1;
      j +:= 1
    }
  }
}

// This could be used to make the input system non case sensitive.
let to_upper(s) be {
  let end = strlen(s);
  let i = 0;
  let ch = 0;
  while i < end do { 
    out ("%d: %d\n", i, byte i of s);
    if byte i of s >= 97 then 
      if byte i of s <= 122 then 
        byte i of s -:= 32;
    i +:= 1;
  }

  out("big: %s \n", s);
}
  
// Get user input and process it.
let process_cmd() be {
  let cmd = vec(5);
  let arg = vec(5);
  let input = vec(7);
  let input_arr = vec(10);  // arr ! 0 = cmd, arr ! 1 = arg;

  while true do {
    out("$ ");    
    // input := get_usr_input(input_arr);   // Get raw input from user.

    // cmd := get_string();
    // out("cmd: %s \n", cmd);
    input := getline();
    out ("input: %s \n", input!0);
    parse(input, cmd, arg);

    
    // arg := get_string();
    out("arg: %s \n", arg);
    out("cmd: %s \n", cmd);

    test strcmp(cmd, "echo") then 
      echo(arg)
    else test strcmp(cmd, "exit") then 
      exit()
    else test strcmp(cmd, "time") then 
      time()
    else test strcmp(cmd, "") then 
      loop
    else
      out("%s: Command not found. \n", cmd);

  }  
}

let change(mp) be {
  mp ! 0 := "blah";

}

let start() be 
{
  // let p = vec(3);
  // change(p);
  // out("changed: %s \n", p ! 0);
  // let heap = vec(10000);
  // init(heap, 10000);
  process_cmd(); 
}
